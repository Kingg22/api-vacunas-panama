-- tables with PK, NOT NULL, default and UNIQUE CONSTRAINTs
CREATE TABLE IF NOT EXISTS provincias
(
    id     SMALLINT GENERATED BY DEFAULT AS IDENTITY (MINVALUE 0 START WITH 0 INCREMENT BY 1),
    nombre VARCHAR(30) NOT NULL,        -- NOSONAR
    PRIMARY KEY (id),
    CONSTRAINT ck_provincia_existe CHECK (
        nombre IN (
                   'Por registrar',     -- Problemas o nueva provincia sin registrar aún
                   'Bocas del Toro',    -- 1
                   'Coclé',             -- 2
                   'Colón',             -- 3
                   'Chiriquí',          -- 4
                   'Darién',            -- 5
                   'Herrera',           -- 6
                   'Los Santos',        -- 7
                   'Panamá',            -- 8
                   'Veraguas',          -- 9
                   'Guna Yala',         -- 10
                   'Emberá-Wounaan',    -- 11
                   'Ngäbe-Buglé',       -- 12
                   'Panamá Oeste',      -- 13
                   'Naso Tjër Di',      -- 14
                   'Guna de Madugandí', -- 15
                   'Guna de Wargandí',  -- 16
                   'Extranjero'         -- 17
            )
        )
);

CREATE TABLE IF NOT EXISTS distritos
(
    id        SMALLINT GENERATED BY DEFAULT AS IDENTITY (MINVALUE 0 START WITH 0 INCREMENT BY 1),
    provincia SMALLINT     NOT NULL,
    nombre    VARCHAR(100) NOT NULL, -- NOSONAR
    PRIMARY KEY (id),
    CONSTRAINT fk_distritos_provincias FOREIGN KEY (provincia) REFERENCES provincias (id),
    CONSTRAINT ck_distritos_provincias CHECK (
        (provincia = 0 AND nombre = 'Por registrar') OR
        (provincia = 1 AND nombre IN ('Almirante', 'Bocas del Toro', 'Changuinola', 'Chiriquí Grande')) OR
        (provincia = 2 AND nombre IN ('Aguadulce', 'Antón', 'La Pintada', 'Natá', 'Olá', 'Penonomé')) OR
        (provincia = 3 AND
         nombre IN ('Chagres', 'Colón', 'Donoso', 'Portobelo', 'Santa Isabel', 'Omar Torrijos Herrera')) OR
        (provincia = 4 AND nombre IN
                           ('Alanje', 'Barú', 'Boquerón', 'Boquete', 'Bugaba', 'David', 'Dolega', 'Gualaca', 'Remedios',
                            'Renacimiento', 'San Félix', 'San Lorenzo', 'Tierras Altas', 'Tolé')) OR
        (provincia = 5 AND nombre IN ('Chepigana', 'Pinogana', 'Santa Fe', 'Guna de Wargandí')) OR
        (provincia = 6 AND nombre IN ('Chitré', 'Las Minas', 'Los Pozos', 'Ocú', 'Parita', 'Pesé', 'Santa María')) OR
        (provincia = 7 AND
         nombre IN ('Guararé', 'Las Tablas', 'Los Santos', 'Macaracas', 'Pedasí', 'Pocrí', 'Tonosí')) OR
        (provincia = 8 AND nombre IN ('Balboa', 'Chepo', 'Chimán', 'Panamá', 'San Miguelito', 'Taboga')) OR
        (provincia = 9 AND nombre IN ('Atalaya', 'Calobre', 'Cañazas', 'La Mesa', 'Las Palmas', 'Mariato', 'Montijo',
                                      'Río de Jesús', 'San Francisco', 'Santa Fe', 'Santiago', 'Soná')) OR
        (provincia = 11 AND nombre IN ('Cémaco', 'Sambú')) OR
        (provincia = 12 AND nombre IN
                            ('Besikó', 'Jirondai', 'Kankintú', 'Kusapín', 'Mironó', 'Müna', 'Nole Duima', 'Ñürüm',
                             'Santa Catalina', 'Calovébora')) OR
        (provincia = 13 AND nombre IN ('Arraiján', 'Capira', 'Chame', 'La Chorrera', 'San Carlos')) OR
        (provincia = 14 AND nombre IN ('Naso Tjër Di')) OR
        (provincia = 17 AND nombre IN ('Extranjero')) OR
        (provincia IS NULL AND nombre IS NULL)
        )
);

CREATE TABLE IF NOT EXISTS direcciones
(
    id         UUID         NOT NULL DEFAULT gen_random_UUID(),
    direccion  VARCHAR(150) NOT NULL, -- NOSONAR
    created_at TIMESTAMP(0) NOT NULL DEFAULT now(),
    updated_at TIMESTAMP(0),
    distrito   SMALLINT     NOT NULL DEFAULT 0,
    PRIMARY KEY (id),
    CONSTRAINT fk_direcciones_distritos FOREIGN KEY (distrito) REFERENCES distritos (id)
);

CREATE TABLE IF NOT EXISTS permisos
(
    id          SMALLINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
    created_at  TIMESTAMP(0) NOT NULL DEFAULT now(),
    updated_at  TIMESTAMP(0),
    descripcion VARCHAR(100),          -- NOSONAR
    nombre      VARCHAR(100) NOT NULL, -- NOSONAR
    PRIMARY KEY (id),
    CONSTRAINT uq_permisos_nombre UNIQUE (nombre)
);

CREATE TABLE IF NOT EXISTS roles
(
    id          SMALLINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
    created_at  TIMESTAMP(0) NOT NULL DEFAULT now(),
    updated_at  TIMESTAMP(0),
    descripcion VARCHAR(100),          -- NOSONAR
    nombre      VARCHAR(100) NOT NULL, -- NOSONAR
    PRIMARY KEY (id),
    CONSTRAINT uq_roles_rol UNIQUE (nombre)
);

CREATE TABLE IF NOT EXISTS roles_permisos
(
    permiso    SMALLINT     NOT NULL,
    rol        SMALLINT     NOT NULL,
    created_at TIMESTAMP(0) NOT NULL DEFAULT now(),
    updated_at TIMESTAMP(0),
    PRIMARY KEY (permiso, rol),
    CONSTRAINT fk_roles_permisos_roles FOREIGN KEY (rol) REFERENCES roles (id),
    CONSTRAINT fk_roles_permisos_permisos FOREIGN KEY (permiso) REFERENCES permisos (id)
);

CREATE TABLE IF NOT EXISTS usuarios
(
    created_at TIMESTAMP(0) NOT NULL DEFAULT now(),
    last_used  TIMESTAMP(0),
    updated_at TIMESTAMP(0),
    id         UUID         NOT NULL DEFAULT gen_random_uuid(),
    usuario    VARCHAR(50),           -- NOSONAR
    clave      VARCHAR(100) NOT NULL, -- NOSONAR
    PRIMARY KEY (id),
    CONSTRAINT uq_usuarios_username UNIQUE (usuario),
    CONSTRAINT ck_usuarios_clave CHECK (clave ~ '^\\$2[ayb]\\$[0-9]{2}\\$[A-Za-z0-9./]{22}$')
);

CREATE TABLE IF NOT EXISTS usuarios_roles
(
    rol        INT          NOT NULL,
    created_at TIMESTAMP(0) NOT NULL DEFAULT now(),
    updated_at TIMESTAMP(0),
    usuario    UUID         NOT NULL,
    PRIMARY KEY (rol, usuario),
    CONSTRAINT fk_usuarios_roles_usuarios FOREIGN KEY (usuario) REFERENCES usuarios (id),
    CONSTRAINT fk_usuarios_roles_roles FOREIGN KEY (rol) REFERENCES roles (id)
);

CREATE TABLE IF NOT EXISTS personas
(
    disabled         BOOLEAN     NOT NULL DEFAULT FALSE,
    edad             SMALLINT,
    sexo             VARCHAR(1),                                    -- NOSONAR
    fecha_nacimiento TIMESTAMP(0),
    cedula           VARCHAR(15),                                -- NOSONAR
    telefono         VARCHAR(15),                                -- NOSONAR
    direccion        UUID        NOT NULL,
    id               UUID        NOT NULL DEFAULT gen_random_uuid(),
    usuario          UUID,
    pasaporte        VARCHAR(20),                                -- NOSONAR
    estado           VARCHAR(50) NOT NULL DEFAULT 'NO_VALIDADO', -- NOSONAR
    apellido1        VARCHAR(100),                               -- NOSONAR
    apellido2        VARCHAR(100),                               -- NOSONAR
    nombre           VARCHAR(100),                               -- NOSONAR
    nombre2          VARCHAR(100),                               -- NOSONAR
    correo           VARCHAR(254),                               -- NOSONAR
    PRIMARY KEY (id),
    CONSTRAINT fk_personas_direcciones FOREIGN KEY (direccion) REFERENCES direcciones (id),
    CONSTRAINT fk_personas_usuarios FOREIGN KEY (usuario) REFERENCES usuarios (id),
    CONSTRAINT ck_personas_sexo CHECK (sexo IN ('M', 'F')),
    CONSTRAINT ck_personas_telefono CHECK (
        telefono IS NULL OR (
            telefono ~ '^\+[0-9]{4,}$')),

    CONSTRAINT ck_fabricantes_contacto_correo CHECK (
        correo IS NULL OR
        (correo ~* '^[^@]+@[^@]+\.[a-z]{2,}$' AND length(correo) >= 5)),

    CONSTRAINT ck_personas_cedula CHECK (
        cedula IS NULL OR (
            cedula ~ '^(PE|E|N|[2-9](AV|PI)?|1[0-3]?(AV|PI)?)-\d{1,4}-\d{1,6}$')),

    CONSTRAINT ck_personas_pasaporte CHECK (
        pasaporte IS NULL OR (pasaporte ~ '^[A-Z0-9]{5,}$')),

    CONSTRAINT ck_personas_fecha_nacimiento CHECK (
        fecha_nacimiento IS NULL OR fecha_nacimiento <= CURRENT_DATE),

    CONSTRAINT ck_personas_estado CHECK (estado IN
                                         ('ACTIVO', 'NO_VALIDADO', 'FALLECIDO', 'INACTIVO', 'DESACTIVADO'))
);

CREATE TABLE IF NOT EXISTS entidades
(
    disabled    BOOLEAN      NOT NULL DEFAULT FALSE,
    dependencia VARCHAR(13),                            -- NOSONAR
    telefono    VARCHAR(15),                            -- NOSONAR
    direccion   UUID         NOT NULL,
    id          UUID         NOT NULL DEFAULT gen_random_uuid(),
    estado      VARCHAR(50)  NOT NULL DEFAULT 'ACTIVO', -- NOSONAR
    nombre      VARCHAR(100) NOT NULL,                  -- NOSONAR
    correo      VARCHAR(254),                           -- NOSONAR
    PRIMARY KEY (id),
    CONSTRAINT fk_entidades_direcciones FOREIGN KEY (direccion) REFERENCES direcciones (id),
    -- Validación básica de correo
    CONSTRAINT ck_entidades_correo CHECK (
        correo IS NULL OR
        (correo ~* '^[^@]+@[^@]+\.[a-z]{2,}$' AND length(correo) >= 5)),

    -- Teléfono con formato internacional, ejemplo: +50760001234
    CONSTRAINT ck_entidades_telefono CHECK (
        telefono IS NULL OR
            -- Al menos 4 dígitos luego del +
        (telefono ~ '^\+[0-9]{4,}$')),

    -- Dependencia controlada por catálogo fijo
    CONSTRAINT ck_entidades_dependencia CHECK (
        dependencia IS NULL OR
        dependencia IN ('CSS', 'MINSA', 'PRIVADA', 'POR_REGISTRAR')),

    -- Estado restringido
    CONSTRAINT ck_entidades_estado CHECK (estado IN ('ACTIVO', 'NO_VALIDADO', 'INACTIVO', 'DESACTIVADO'))
);

CREATE TABLE IF NOT EXISTS fabricantes
(
    created_at        TIMESTAMP(0) NOT NULL DEFAULT now(),
    updated_at        TIMESTAMP(0),
    contacto_telefono VARCHAR(15),           -- NOSONAR
    id                UUID         NOT NULL DEFAULT gen_random_uuid(),
    usuario           UUID,
    licencia          VARCHAR(50)  NOT NULL, -- NOSONAR
    contacto_nombre   VARCHAR(100),          -- NOSONAR
    contacto_correo   VARCHAR(254),          -- NOSONAR
    PRIMARY KEY (id),
    CONSTRAINT fk_fabricantes_usuarios FOREIGN KEY (usuario) REFERENCES usuarios (id),
    CONSTRAINT fk_fabricantes_entidades FOREIGN KEY (id) REFERENCES entidades (id),
    CONSTRAINT ck_fabricantes_licencia CHECK (licencia LIKE '%/DNFD'),
    -- Validación básica de correo
    CONSTRAINT ck_fabricantes_contacto_correo CHECK (
        contacto_correo IS NULL OR
        (contacto_correo ~* '^[^@]+@[^@]+\.[a-z]{2,}$' AND length(contacto_correo) >= 5)),

    -- Teléfono con formato internacional, ejemplo: +50760001234
    CONSTRAINT ck_fabricantes_contacto_telefono CHECK (
        contacto_telefono IS NULL OR
            -- Al menos 4 dígitos luego del +
        (contacto_telefono ~ '^\+[0-9]{4,}$'))
);

CREATE TABLE IF NOT EXISTS sedes
(
    created_at TIMESTAMP(0) NOT NULL DEFAULT now(),
    updated_at TIMESTAMP(0),
    id         UUID         NOT NULL DEFAULT gen_random_uuid(),
    region     VARCHAR(50), -- NOSONAR
    PRIMARY KEY (id),
    CONSTRAINT fk_sedes_entidades FOREIGN KEY (id) REFERENCES entidades (id)
);

CREATE TABLE IF NOT EXISTS doctores
(
    created_at TIMESTAMP(0) NOT NULL DEFAULT now(),
    updated_at TIMESTAMP(0),
    id         UUID         NOT NULL DEFAULT gen_random_uuid(),
    sede       UUID,
    idoneidad  VARCHAR(20)  NOT NULL, -- NOSONAR
    categoria  VARCHAR(100),          -- NOSONAR
    PRIMARY KEY (id),
    CONSTRAINT fk_doctores_sedes FOREIGN KEY (sede) REFERENCES sedes (id),
    CONSTRAINT fk_doctores_personas FOREIGN KEY (id) REFERENCES personas (id)
);

CREATE TABLE IF NOT EXISTS pacientes
(
    created_at              TIMESTAMP(0) NOT NULL DEFAULT now(),
    updated_at              TIMESTAMP(0),
    id                      UUID         NOT NULL DEFAULT gen_random_uuid(),
    identificacion_temporal VARCHAR(255), -- NOSONAR
    PRIMARY KEY (id),
    CONSTRAINT fk_pacientes_personas FOREIGN KEY (id) REFERENCES personas (id),
    CONSTRAINT uq_pacientes_id_temporal UNIQUE (identificacion_temporal),
    CONSTRAINT ck_pacientes_id_temporal CHECK (
        -- Opción 1: No identificado
        identificacion_temporal ~ '^NI-\w+$'
            OR
            -- Opción 2: Recién nacidos
        (
            (
                -- Debe empezar con RN-, RN1-, RN2-, ..., RN99-
                identificacion_temporal ~ '^RN([1-9][0-9]?)?-'

                    -- Y contener uno de los tipos válidos: -PE-, -E-, -N-, -1-, ... -13-
                    AND identificacion_temporal ~ '(PE|E|N|[2-9](AV|PI)?|1[0-3]?(AV|PI)?)'

                    -- y tener un libro de 4 dígitos
                    AND identificacion_temporal ~ '-\d{4}-'

                    -- y terminar con tomo de 6 dígitos (ej.: 000123)
                    AND identificacion_temporal ~ '-\d{6}$'
                )
            )
        )
);

CREATE TABLE IF NOT EXISTS vacunas
(
    edad_minima_dias SMALLINT     NOT NULL,
    created_at       TIMESTAMP(0) NOT NULL DEFAULT now(),
    updated_at       TIMESTAMP(0),
    id               UUID         NOT NULL DEFAULT gen_random_uuid(),
    nombre           VARCHAR(100) NOT NULL, -- NOSONAR
    dosis_maxima     VARCHAR(2),            -- NOSONAR
    PRIMARY KEY (id),
    CONSTRAINT ck_vacunas_dosis_maxima CHECK (dosis_maxima IN ('1', '2', '3', 'R', 'R1', 'R2', 'P')),
    CONSTRAINT ck_vacunas_edad_minima CHECK (edad_minima_dias >= 0)
);

CREATE TABLE IF NOT EXISTS esquemas_vacunacion
(
    id               UUID DEFAULT gen_random_uuid(),
    vacuna           UUID       NOT NULL,
    numero_dosis     VARCHAR(2) NOT NULL,
    intervalo_inicio INT,
    intervalo_fin    INT,
    PRIMARY KEY (id),
    CONSTRAINT fk_esquemas_vacunacion_vacuna FOREIGN KEY (vacuna) REFERENCES vacunas (id),
    CONSTRAINT ck_esquemas_vacunacion_intervalo_dosis CHECK (intervalo_inicio <= intervalo_fin),
    CONSTRAINT ck_esquemas_vacunacion_dosis_maxima CHECK (numero_dosis IN ('1', '2', '3', 'R', 'R1', 'R2', 'P'))
);

CREATE TABLE IF NOT EXISTS fabricantes_vacunas
(
    fabricante UUID NOT NULL,
    vacuna     UUID NOT NULL,
    PRIMARY KEY (fabricante, vacuna),
    CONSTRAINT fk_fabricantes_vacunas_vacunas FOREIGN KEY (vacuna) REFERENCES vacunas (id),
    CONSTRAINT fk_fabricantes_vacunas_fabricantes FOREIGN KEY (fabricante) REFERENCES fabricantes (id)
);

CREATE TABLE IF NOT EXISTS dosis
(
    numero_dosis     VARCHAR(2)   NOT NULL, -- NOSONAR
    created_at       TIMESTAMP(0) NOT NULL DEFAULT now(),
    fecha_aplicacion TIMESTAMP(0) NOT NULL DEFAULT now(),
    updated_at       TIMESTAMP(0),
    doctor           UUID,
    id               UUID         NOT NULL DEFAULT gen_random_uuid(),
    paciente         UUID         NOT NULL,
    sede             UUID         NOT NULL,
    vacuna           UUID         NOT NULL,
    lote             VARCHAR(50),           -- NOSONAR
    PRIMARY KEY (id),
    CONSTRAINT ck_dosis_numero_dosis CHECK (numero_dosis IN ('1', '2', '3', 'R', 'R1', 'R2', 'P')),
    CONSTRAINT fk_dosis_doctores FOREIGN KEY (doctor) REFERENCES doctores (id),
    CONSTRAINT fk_dosis_pacientes FOREIGN KEY (paciente) REFERENCES pacientes (id),
    CONSTRAINT fk_dosis_sedes FOREIGN KEY (sede) REFERENCES sedes (id),
    CONSTRAINT fk_dosis_vacunas FOREIGN KEY (vacuna) REFERENCES vacunas (id)
);

-- indexes
CREATE INDEX IF NOT EXISTS ix_direcciones_direccion ON direcciones (direccion);

CREATE INDEX IF NOT EXISTS ix_distritos_nombre ON distritos (nombre);

CREATE INDEX IF NOT EXISTS ix_doctores_idoneidad ON doctores (idoneidad);

CREATE INDEX IF NOT EXISTS ix_fabricantes_licencia ON fabricantes (licencia);

CREATE UNIQUE INDEX IF NOT EXISTS ix_fabricantes_usuario ON fabricantes (usuario) WHERE usuario IS NOT NULL;

CREATE INDEX IF NOT EXISTS ix_permisos_nombre ON permisos (nombre);

CREATE INDEX IF NOT EXISTS ix_personas_nombres_apellidos ON personas (nombre, nombre2, apellido1, apellido2);

CREATE UNIQUE INDEX IF NOT EXISTS ix_entidades_correo ON entidades (correo) WHERE correo IS NOT NULL;

CREATE UNIQUE INDEX IF NOT EXISTS ix_entidades_telefono ON entidades (telefono) WHERE telefono IS NOT NULL;

CREATE UNIQUE INDEX IF NOT EXISTS ix_pacientes_id_temporal ON pacientes (identificacion_temporal) WHERE identificacion_temporal IS NOT NULL;

CREATE UNIQUE INDEX IF NOT EXISTS ix_personas_cedula ON personas (cedula) WHERE cedula IS NOT NULL;

CREATE UNIQUE INDEX IF NOT EXISTS ix_personas_pasaporte ON personas (pasaporte) WHERE pasaporte IS NOT NULL;

CREATE UNIQUE INDEX IF NOT EXISTS ix_personas_correo ON personas (correo) WHERE correo IS NOT NULL;

CREATE UNIQUE INDEX IF NOT EXISTS ix_personas_telefono ON personas (telefono) WHERE telefono IS NOT NULL;

CREATE UNIQUE INDEX IF NOT EXISTS ix_personas_usuario ON personas (usuario) WHERE usuario IS NOT NULL;

CREATE INDEX IF NOT EXISTS ix_provincias_nombre ON provincias (nombre);

CREATE INDEX IF NOT EXISTS ix_sedes_region ON sedes (region) WHERE region IS NOT NULL;

CREATE INDEX IF NOT EXISTS ix_usuarios_username ON usuarios (usuario);

CREATE INDEX IF NOT EXISTS ix_vacunas_nombre ON vacunas (nombre);

-- Trigger para asignar automáticamente la región a las sedes cuando coincide con la provincia y/o distrito
CREATE OR REPLACE FUNCTION tr_sedes_insert_region_fn()
    RETURNS TRIGGER AS
$$
DECLARE
    prov_id     INTEGER;
    distrito_id INTEGER;
BEGIN
    SELECT dd.provincia, d.distrito
    INTO prov_id, distrito_id
    FROM entidades e
             INNER JOIN direcciones d ON e.direccion = d.id
             INNER JOIN distritos dd ON d.distrito = dd.id
    WHERE e.id = NEW.id;

    NEW.region := CASE
                      WHEN prov_id = 1 THEN 'Bocas del Toro'
                      WHEN prov_id = 2 THEN 'Coclé'
                      WHEN prov_id = 3 THEN 'Colón'
                      WHEN prov_id = 4 THEN 'Chiriquí'
                      WHEN prov_id = 5 OR prov_id = 11 OR prov_id = 16
                          THEN 'Darién y la comarca Embera Waunán y Wargandí'
                      WHEN prov_id = 6 THEN 'Herrera'
                      WHEN prov_id = 7 THEN 'Los Santos'
                      WHEN prov_id = 8 AND distrito_id = 53 THEN 'San Miguelito'
                      WHEN prov_id = 8 AND distrito_id <> 53 THEN 'Panamá Norte/Este/Metro'
                      WHEN prov_id = 9 THEN 'Veraguas'
                      WHEN prov_id = 10 THEN 'Kuna Yala'
                      WHEN prov_id = 12 THEN 'Ngabe Buglé'
                      WHEN prov_id = 13 AND distrito_id <> 79 THEN 'Panamá Oeste'
                      WHEN prov_id = 13 AND distrito_id = 79 THEN 'Arraiján'
                      ELSE 'Por registrar'
        END;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER tr_sedes_insert_region
    BEFORE INSERT OR UPDATE
    ON sedes
    FOR EACH ROW
EXECUTE FUNCTION tr_sedes_insert_region_fn();

-- trigger para mantener registro de cambios
CREATE OR REPLACE FUNCTION set_updated_at()
    RETURNS TRIGGER AS
$$
BEGIN
    IF NEW IS DISTINCT FROM OLD THEN
        NEW.updated_at := CURRENT_TIMESTAMP;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER tr_usuarios_updated
    BEFORE UPDATE
    ON usuarios
    FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE OR REPLACE TRIGGER tr_doctores_updated
    BEFORE UPDATE
    ON doctores
    FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE OR REPLACE TRIGGER tr_pacientes_updated
    BEFORE UPDATE
    ON pacientes
    FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE OR REPLACE TRIGGER tr_sedes_updated
    BEFORE UPDATE
    ON sedes
    FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE OR REPLACE TRIGGER tr_rol_updated
    BEFORE UPDATE
    ON roles
    FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE OR REPLACE TRIGGER tr_permisos_updated
    BEFORE UPDATE
    ON permisos
    FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE OR REPLACE TRIGGER tr_rol_permisos_updated
    BEFORE UPDATE
    ON roles_permisos
    FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE OR REPLACE TRIGGER tr_vacunas_updated
    BEFORE UPDATE
    ON vacunas
    FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE OR REPLACE TRIGGER tr_usuario_rol_updated
    BEFORE UPDATE
    ON usuarios_roles
    FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE OR REPLACE TRIGGER tr_direcciones_updated
    BEFORE UPDATE
    ON direcciones
    FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE OR REPLACE TRIGGER tr_dosis_updated
    BEFORE UPDATE
    ON dosis
    FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE OR REPLACE TRIGGER tr_fabricantes_updated
    BEFORE UPDATE
    ON fabricantes
    FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

-- Trigger que le da formato a la cédula panameña al insertar y asigna la edad de la persona
CREATE OR REPLACE FUNCTION fn_personas_format_insert()
    RETURNS TRIGGER AS
$$
DECLARE
    inicio TEXT;
    libro  TEXT;
    tomo   TEXT;
BEGIN
    IF NEW.fecha_nacimiento IS NOT NULL THEN
        NEW.edad := DATE_PART('year', AGE(CURRENT_DATE, NEW.fecha_nacimiento));
    END IF;

    IF NEW.cedula IS NOT NULL THEN
        -- Validar formato general
        IF NOT (
            NEW.cedula ~ '^(PE|E|N|[2-9](AV|PI)?|1[0-3]?(AV|PI)?)-\d{1,4}-\d{1,6}$'
            ) THEN
            RAISE EXCEPTION 'Cédula no cumple el formato: %', NEW.cedula;
        END IF;

        -- Formateo individual
        inicio := split_part(NEW.cedula, '-', 1);
        libro := lpad(split_part(NEW.cedula, '-', 2), 4, '0');
        tomo := lpad(split_part(NEW.cedula, '-', 3), 6, '0');

        NEW.cedula := inicio || '-' || libro || '-' || tomo;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER tr_personas_format_insert
    BEFORE INSERT
    ON personas
    FOR EACH ROW
EXECUTE FUNCTION fn_personas_format_insert();

-- Trigger que le da formato a identificación temporal con cédulas de la madre
CREATE OR REPLACE FUNCTION fn_pacientes_format_insert()
    RETURNS TRIGGER AS
$$
DECLARE
    inicio        TEXT;
    libro         TEXT;
    tomo          TEXT;
    cedula_madre  TEXT;
    recien_nacido TEXT;
BEGIN
    IF NEW.identificacion_temporal IS NOT NULL AND NEW.identificacion_temporal ~ '^RN[0-9]*-' THEN
        recien_nacido := split_part(NEW.identificacion_temporal, '-', 1);
        cedula_madre := split_part(NEW.identificacion_temporal, '-', 2);

        -- Validación de formato
        IF NOT (cedula_madre ~ '^(PE|E|N|[2-9](AV|PI)?|1[0-3]?(AV|PI)?)-\d{1,4}-\d{1,6}$') THEN
            RAISE EXCEPTION 'Cédula madre no cumple el formato: %', cedula_madre;
        END IF;

        inicio := split_part(cedula_madre, '-', 1);
        libro := lpad(split_part(cedula_madre, '-', 2), 4, '0');
        tomo := lpad(split_part(cedula_madre, '-', 3), 6, '0');

        NEW.identificacion_temporal := recien_nacido || '-' || inicio || '-' || libro || '-' || tomo;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER tr_pacientes_format_insert
    BEFORE INSERT
    ON pacientes
    FOR EACH ROW
EXECUTE FUNCTION fn_pacientes_format_insert();

-- Trigger para evaluar la secuencia de dosis
CREATE OR REPLACE FUNCTION trg_validate_dosis_sequence()
    RETURNS TRIGGER AS
$$
DECLARE
    num_dosis   TEXT;
    id_paciente UUID;
    id_vacuna   UUID;
BEGIN
    num_dosis := UPPER(TRIM(NEW.numero_dosis));
    id_paciente := NEW.paciente;
    id_vacuna := NEW.vacuna;

    -- Validar dosis previas en secuencia
    IF num_dosis = 'P' AND EXISTS (SELECT 1
                                   FROM dosis
                                   WHERE paciente = id_paciente
                                     AND vacuna = id_vacuna) THEN
        RAISE EXCEPTION 'La dosis P solo puede aplicarse antes de cualquier otra dosis de esa vacuna';
    END IF;

    IF num_dosis = '2' AND NOT EXISTS (SELECT 1
                                       FROM dosis
                                       WHERE paciente = id_paciente
                                         AND vacuna = id_vacuna
                                         AND numero_dosis = '1') THEN
        RAISE EXCEPTION 'Debe existir la dosis 1 antes de aplicar la dosis 2';
    END IF;

    IF num_dosis = '3' AND NOT EXISTS (SELECT 1
                                       FROM dosis
                                       WHERE paciente = id_paciente
                                         AND vacuna = id_vacuna
                                         AND numero_dosis = '2') THEN
        RAISE EXCEPTION 'Debe existir la dosis 2 antes de aplicar la dosis 3';
    END IF;

    IF num_dosis = 'R1' AND NOT EXISTS (SELECT 1
                                        FROM dosis
                                        WHERE paciente = id_paciente
                                          AND vacuna = id_vacuna
                                          AND numero_dosis = '1') THEN
        RAISE EXCEPTION 'Debe existir la dosis 1 antes de aplicar la dosis R1';
    END IF;

    IF num_dosis = 'R2' AND NOT EXISTS (SELECT 1
                                        FROM dosis
                                        WHERE paciente = id_paciente
                                          AND vacuna = id_vacuna
                                          AND numero_dosis IN ('R1', '1')) THEN
        RAISE EXCEPTION 'Debe existir la dosis R1 o 1 antes de aplicar la dosis R2';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER tr_validate_dosis_sequence
    BEFORE INSERT
    ON dosis
    FOR EACH ROW
EXECUTE FUNCTION trg_validate_dosis_sequence();
